
protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, 
                      final @Nullable Object[] args)  throws BeanCreationException {
    // 一. (1.)实例化
    BeanWrapper instanceWrapper = null;
		...   ...	
    if (instanceWrapper == null) {
		//创建实例化
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
		...   ... 
    Object exposedObject = bean;
    try {
        // 二. (2.)属性赋值
        populateBean(beanName, mbd, instanceWrapper);
        // 三. (3-7.)初始化
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }
		...   ...
    // 四. 销毁-8.注册Destruction相关回调接口
    try {
	    //将销毁Bean添加到可丢弃Bean列表中。单例模式，注册一个disposableBean；其他模式，
		//注册一个回调方法，当需要销毁或者作用域销毁的时候调用。
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    }
		...   ...
    return exposedObject;
}


protected Object initializeBean(final String beanName,final Object bean,@Nullable RootBeanDefinition mbd){
    // 3. 检查Aware相关接口并设置相关依赖
    if (System.getSecurityManager() != null) {
        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
            invokeAwareMethods(beanName, bean);
            return null;
        }, getAccessControlContext());
    }
    else {  invokeAwareMethods(beanName, bean); }
    // 4. BeanPostProcessor前置处理
    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }
    // 5. 若实现InitializingBean接口，则调用afterPropertiesSet()方法
    // 6. 若配置自定义的 init-method方法，则执行
	// 注：在invokInitMethods()方法中会检查InitializingBean接口和init-method方法
    try {
        invokeInitMethods(beanName, wrappedBean, mbd);
    } catch (Throwable ex) {
        throw new BeanCreationException((mbd != null ? mbd.getResourceDescription() : null),
            beanName, "Invocation of init method failed", ex);
    }
    // 7. BeanPostProceesor 后置处理
    if (mbd == null || !mbd.isSynthetic()) {
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
    return wrappedBean;
}

public void destroy() {
		...   ...	
    // 9. 若实现 DisposableBean 接口，则执行 destory()方法
    if (this.invokeDisposableBean) {
        try {
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
                    ((DisposableBean) this.bean).destroy();
                    return null;
                }, this.acc);
            }
            else {
                ((DisposableBean) this.bean).destroy();
            }catch (Throwable ex) {
				String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'";
				if (logger.isDebugEnabled()) { logger.warn(msg, ex); }else { logger.warn(msg + ": " + ex);  }
			}
        }
    }
    // 10. 若配置自定义的 detory-method 方法，则执行
    if (this.destroyMethod != null) {
        invokeCustomDestroyMethod(this.destroyMethod);
    }
    else if (this.destroyMethodName != null) {
        Method methodToInvoke = determineDestroyMethod(this.destroyMethodName);
        if (methodToInvoke != null) {
            invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));
        }
    }
}

public interface BeanPostProcessor {
    // 初始化前置处理
	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
	// 初始化后置处理
	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
}


